/*
** YUNI's default license is the GNU Lesser Public License (LGPL), with some
** exclusions (see below). This basically means that you can get the full source
** code for nothing, so long as you adhere to a few rules.
**
** Under the LGPL you may use YUNI for any purpose you wish, and modify it if you
** require, as long as you:
**
** Pass on the (modified) YUNI source code with your software, with original
** copyrights intact :
**  * If you distribute electronically, the source can be a separate download
**    (either from your own site if you modified YUNI, or to the official YUNI
**    website if you used an unmodified version) â€“ just include a link in your
**    documentation
**  * If you distribute physical media, the YUNI source that you used to build
**    your application should be included on that media
** Make it clear where you have customised it.
**
** In addition to the LGPL license text, the following exceptions / clarifications
** to the LGPL conditions apply to YUNI:
**
**  * Making modifications to YUNI configuration files, build scripts and
**    configuration headers such as yuni/platform.h in order to create a
**    customised build setup of YUNI with the otherwise unmodified source code,
**    does not constitute a derived work
**  * Building against YUNI headers which have inlined code does not constitute a
**    derived work
**  * Code which subclasses YUNI classes outside of the YUNI libraries does not
**    form a derived work
**  * Statically linking the YUNI libraries into a user application does not make
**    the user application a derived work.
**  * Using source code obsfucation on the YUNI source code when distributing it
**    is not permitted.
** As per the terms of the LGPL, a "derived work" is one for which you have to
** distribute source code for, so when the clauses above define something as not
** a derived work, it means you don't have to distribute source code for it.
** However, the original YUNI source code with all modifications must always be
** made available.
*/
#pragma once

/*!
** \internal This file is automatically generated by 'traits.h.generator.hpp'.
** Please make any modifications you wish to this script instead of
** this file, as they will otherwise be lost at the next generation.
*/
#include "../event/interfaces.h"
#include "../static/inherit.h"
#include "../static/dynamiccast.h"




namespace Yuni
{

	// Forward declaration
	template<class P> class Bind;


} // namespace Yuni

namespace Yuni
{
namespace Private
{
namespace BindImpl
{


	// Forward declarations for classes which will hold informations about the
	// targetted function or member

	/*!
	** \brief Interface
	**
	** \tparam P The prototype of the function/member
	*/
	template<class P> class IPointer;

	/*!
	** \brief Dummy implementation, does nothing, used by unbind
	**
	** \tparam P The prototype of the function/member
	*/
	template<class P> class None;

	/*!
	** \brief Binding with a function
	**
	** \tparam P The prototype of the member
	*/
	template<class P> class BoundWithFunction;

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	/*!
	** \brief Binding with a functor
	**
	** \tparam C The type of the functor
	** \tparam P The prototype of the member
	*/
	template<class C, class P> class BoundWithFunctor;
	# endif

	/*!
	** \brief Binding with a function
	**
	** \tparam U Type of the user data
	** \tparam P The prototype of the member
	*/
	template<class U, class P> class BoundWithFunctionAndUserData;

	/*!
	** \brief Binding with a member
	**
	** \tparam C Any class
	** \tparam P The prototype of the member
	*/
	template<class C, class P> class BoundWithMember;

	/*!
	** \brief Binding with a member and a user data
	**
	** \tparam U Type of the user data
	** \tparam C Any class
	** \tparam P The prototype of the member
	*/
	template<class U, class C, class P> class BoundWithMemberAndUserData;


	/*!
	** \brief Binding with a member
	**
	** \tparam C Any class
	** \tparam P The prototype of the member
	*/
	template<class C, class P> class BoundWithSmartPtrMember;

	/*!
	** \brief Binding with a member and a user data
	**
	** \tparam U Type of the user data
	** \tparam C Any class
	** \tparam P The prototype of the member
	*/
	template<class U, class C, class P> class BoundWithSmartPtrMemberAndUserData;



	template<class T> struct Parameter {
		using Type = const
			typename Static::Remove::Const<	typename Static::Remove::RefOnly<T>::Type>::Type&;
	};

	template<class T> struct Parameter<const T*> {
		using Type = const T*;
	};

	template<class T> struct Parameter<T*> {
		using Type = T*;
	};

	template<class T, int N> struct Parameter<const T[N]> {
		using Type = const T*;
	};

	template<class T, int N> struct Parameter<T[N]> {
		using Type = T*;
	};

	template<class T> struct Parameter<T&> {
		using Type = const T&;
	};

	template<class T> struct Parameter<const T&> {
		using Type = const T&;
	};




	template<class R, class... A>
	struct IPointer<R(A...)>
	{
		//! Destructor
		virtual ~IPointer() = default;
		//! Invoke the delegate
		virtual R invoke(A...) const = 0;
		//! Get if the object is binded
		virtual bool empty() const { return false; }
		//! Get the pointer to object
		virtual const void* object() const = 0;
		//! Get the pointer to object cast into IEventObserverBase
		virtual const IEventObserverBase* observerBaseObject() const = 0;
		//! Get if the attached class is a descendant of 'IEventObserverBase'
		virtual bool isDescendantOf(const IEventObserverBase*) const = 0;
		//! Get if the attached class is a descendant of 'IEventObserverBase'
		virtual bool isDescendantOfIEventObserverBase() const = 0;
		//! Compare with a mere pointer-to-function
		virtual bool compareWithPointerToFunction(R (*pointer)(A...)) const = 0;
		//! Compare with a pointer-to-object
		virtual bool compareWithPointerToObject(const void* object) const = 0;
	};


	template<class R, class... A>
	struct None<R (A...)> final: public IPointer<R (A...)>
	{
		R invoke(A...) const override { return R(); }
		bool empty() const override { return true; }
		const void* object() const override { return NULL; }
		const IEventObserverBase* observerBaseObject() const override { return NULL; }
		bool isDescendantOf(const IEventObserverBase*) const override { return false; }
		bool isDescendantOfIEventObserverBase() const override { return false; }
		bool compareWithPointerToFunction(R (*pointer)(A...)) const override { return !pointer; }
		bool compareWithPointerToObject(const void*) const override { return false; }

	};




	template<class R, class... A>
	struct BoundWithFunction<R (A...)> final: public IPointer<R (A...)>
	{
		BoundWithFunction(R(*pointer)(A...))
			: pPointer(pointer)
		{
			assert(pointer and "binded pointer-to-function can not be null");
		}

		R invoke(A... args) const override
		{
			return (*pPointer)(args...);
		}

		const void* object() const override
		{
			return NULL;
		}

		const IEventObserverBase* observerBaseObject() const override
		{
			return NULL;
		}

		bool isDescendantOf(const IEventObserverBase*) const override
		{
			return false;
		}

		bool isDescendantOfIEventObserverBase() const override
		{
			return false;
		}

		bool compareWithPointerToFunction(R (*pointer)(A...)) const override
		{
			return (reinterpret_cast<void*>(pPointer) == reinterpret_cast<void*>(pointer));
		}

		bool compareWithPointerToObject(const void*) const override
		{
			return false;
		}

	private:
		R (*pPointer)(A...);
	};


	template<class C, class R, class... A>
	struct BoundWithFunctor<C, R (A...)> final: public IPointer<R (A...)>
	{
		BoundWithFunctor(C&& functor)
			: pFunctor(std::forward<C>(functor))
		{}

		R invoke(A... args) const override
		{
			return pFunctor(args...);
		}

		const void* object() const override
		{
			return nullptr;
		}

		const IEventObserverBase* observerBaseObject() const override
		{
			return nullptr;
		}

		bool isDescendantOf(const IEventObserverBase*) const override
		{
			return false;
		}

		bool isDescendantOfIEventObserverBase() const override
		{
			return false;
		}

		bool compareWithPointerToFunction(R (*pointer)(A...)) const override
		{
			return (reinterpret_cast<const void*>(&pFunctor) == reinterpret_cast<const void*>(pointer));
		}

		bool compareWithPointerToObject(const void*) const override
		{
			return false;
		}

	private:
		C pFunctor;
	};


	template<class U, class R, class... A, class A1>
	struct BoundWithFunctionAndUserData<U, R(A..., A1)> final: public IPointer<R (A...)>
	{
		using UserDataTypeByCopy = typename Static::Remove::RefOnly<A1>::Type;

		BoundWithFunctionAndUserData(R(*pointer)(A..., A1), U userdata)
			: pPointer(pointer)
			, pUserdata(userdata)
		{
			assert(pointer and "binded pointer-to-function can not be null");
		}

		R invoke(A... args) const override
		{
			return (*pPointer)(args..., *const_cast<UserDataTypeByCopy*>(&pUserdata));
		}

		const void* object() const override
		{
			return NULL;
		}

		const IEventObserverBase* observerBaseObject() const override
		{
			return NULL;
		}

		bool isDescendantOf(const IEventObserverBase*) const override
		{
			return false;
		}

		bool isDescendantOfIEventObserverBase() const override
		{
			return false;
		}

		bool compareWithPointerToFunction(R (*pointer)(A...)) const override
		{
			return (reinterpret_cast<void*>(pPointer) == reinterpret_cast<void*>(pointer));
		}

		bool compareWithPointerToObject(const void*) const override
		{
			return false;
		}

	private:
		R (*pPointer)(A..., A1);
		UserDataTypeByCopy pUserdata;
	};


	template<class C, class R, class... A>
	struct BoundWithMember<C, R(A...)> final: public IPointer<R(A...)>
	{
		BoundWithMember(C* c, R(C::*member)(A...)) :
			pThis(c),
			pMember(member)
		{
			assert(c and "binded object can not be null");
		}

		R invoke(A... args) const override
		{
			return (pThis->*pMember)(args...);
		}

		const void* object() const override
		{
			return reinterpret_cast<void*>(pThis);
		}

		const IEventObserverBase* observerBaseObject() const override
		{
			return Static::DynamicCastWhenInherits<C,IEventObserverBase>::PerformConst(pThis);
		}

		bool isDescendantOf(const IEventObserverBase* obj) const override
		{
			return Static::DynamicCastWhenInherits<C,IEventObserverBase>::Equals(obj, pThis);
		}

		bool isDescendantOfIEventObserverBase() const override
		{
			return Static::DynamicCastWhenInherits<C,IEventObserverBase>::Yes;
		}

		bool compareWithPointerToFunction(R (*)(A...)) const override
		{
			return false;
		}

		bool compareWithPointerToObject(const void* object) const override
		{
			return (reinterpret_cast<const C*>(object) == pThis);
		}


	private:
		//! Pointer to the object
		mutable C* pThis;
		//! Pointer-to-member
		mutable R (C::*pMember)(A...);
	};


	template<class U, class C, class R, class... A, class A1>
	struct BoundWithMemberAndUserData<U, C, R(A..., A1)> final: public IPointer<R(A...)>
	{
		using UserDataTypeByCopy = typename Static::Remove::RefOnly<A1>::Type;

		BoundWithMemberAndUserData(C* c, R(C::*member)(A..., A1), U userdata)
			: pThis(c)
			, pMember(member)
			, pUserdata(userdata)
		{
			assert(c and "binded object can not be null");
		}

		R invoke(A... args) const override
		{
			return (pThis->*pMember)(args..., const_cast<UserDataTypeByCopy&>(pUserdata));
		}

		const void* object() const override
		{
			return reinterpret_cast<void*>(pThis);
		}

		const IEventObserverBase* observerBaseObject() const override
		{
			return Static::DynamicCastWhenInherits<C,IEventObserverBase>::PerformConst(pThis);
		}

		bool isDescendantOf(const IEventObserverBase* obj) const override
		{
			return Static::DynamicCastWhenInherits<C,IEventObserverBase>::Equals(obj, pThis);
		}

		bool isDescendantOfIEventObserverBase() const override
		{
			return Static::DynamicCastWhenInherits<C,IEventObserverBase>::Yes;
		}


		bool compareWithPointerToFunction(R (*)(A...)) const override
		{
			return false;
		}

		bool compareWithPointerToObject(const void* object) const override
		{
			return (reinterpret_cast<const C*>(object) == pThis);
		}

	private:
		//! Pointer to the object
		mutable C* pThis;
		//! Pointer-to-member
		mutable R (C::*pMember)(A..., A1);
		//! Userdata
		UserDataTypeByCopy pUserdata;
	};


	template<class PtrT, class R, class... A>
	struct BoundWithSmartPtrMember<PtrT, R(A...)> final: public IPointer<R(A...)>
	{
		using C = typename PtrT::Type;

		BoundWithSmartPtrMember(const PtrT& c, R(C::*member)(A...))
			: pThis(c)
			, pMember(member)
		{}

		R invoke(A... args) const override
		{
			return ((pThis.pointer())->*pMember)(args...);
		}

		const void* object() const override
		{
			return reinterpret_cast<void*>(pThis.pointer());
		}

		const IEventObserverBase* observerBaseObject() const override
		{
			return Static::DynamicCastWhenInherits<C,IEventObserverBase>::PerformConst(pThis.pointer());
		}

		bool isDescendantOf(const IEventObserverBase* obj) const override
		{
			return Static::DynamicCastWhenInherits<C,IEventObserverBase>::Equals(obj, pThis.pointer());
		}

		bool isDescendantOfIEventObserverBase() const override
		{
			return Static::DynamicCastWhenInherits<C,IEventObserverBase>::Yes;
		}

		bool compareWithPointerToFunction(R (*)(A...)) const override
		{
			return false;
		}

		bool compareWithPointerToObject(const void* object) const override
		{
			return (reinterpret_cast<const C*>(object) == pThis.pointer());
		}

	private:
		//! Pointer to the object
		mutable PtrT pThis;
		//! Pointer-to-member
		mutable R (C::*pMember)(A...);
	};


	template<class U, class PtrT, class R, class... A, class A1>
	struct BoundWithSmartPtrMemberAndUserData<U, PtrT, R(A..., A1)> final: public IPointer<R(A...)>
	{
		using C = typename PtrT::Type;
		using UserDataTypeByCopy = typename Static::Remove::RefOnly<A1>::Type;

		BoundWithSmartPtrMemberAndUserData(const PtrT& c, R(C::*member)(A..., A1), U userdata)
			: pThis(c)
			, pMember(member)
			, pUserdata(userdata)
		{}

		R invoke(A... args) const override
		{
			return ((pThis.pointer())->*pMember)(args..., const_cast<UserDataTypeByCopy&>(pUserdata));
		}

		const void* object() const override
		{
			return reinterpret_cast<void*>(pThis.pointer());
		}

		const IEventObserverBase* observerBaseObject() const override
		{
			return Static::DynamicCastWhenInherits<C,IEventObserverBase>::PerformConst(pThis.pointer());
		}

		bool isDescendantOf(const IEventObserverBase* obj) const override
		{
			return Static::DynamicCastWhenInherits<C,IEventObserverBase>::Equals(obj, pThis.pointer());
		}

		bool isDescendantOfIEventObserverBase() const override
		{
			return Static::DynamicCastWhenInherits<C,IEventObserverBase>::Yes;
		}


		bool compareWithPointerToFunction(R (*)(A...)) const override
		{
			return false;
		}

		bool compareWithPointerToObject(const void* object) const override
		{
			return (reinterpret_cast<const C*>(object) == pThis.pointer());
		}

	private:
		//! Pointer to the object
		mutable PtrT pThis;
		//! Pointer-to-member
		mutable R (C::*pMember)(A..., A1);
		//! Userdata
		UserDataTypeByCopy pUserdata;
	};


} // namespace BindImpl
} // namespace Private
} // namespace Yuni
