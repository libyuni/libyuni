/*
** YUNI's default license is the GNU Lesser Public License (LGPL), with some
** exclusions (see below). This basically means that you can get the full source
** code for nothing, so long as you adhere to a few rules.
**
** Under the LGPL you may use YUNI for any purpose you wish, and modify it if you
** require, as long as you:
**
** Pass on the (modified) YUNI source code with your software, with original
** copyrights intact :
**  * If you distribute electronically, the source can be a separate download
**    (either from your own site if you modified YUNI, or to the official YUNI
**    website if you used an unmodified version) â€“ just include a link in your
**    documentation
**  * If you distribute physical media, the YUNI source that you used to build
**    your application should be included on that media
** Make it clear where you have customised it.
**
** In addition to the LGPL license text, the following exceptions / clarifications
** to the LGPL conditions apply to YUNI:
**
**  * Making modifications to YUNI configuration files, build scripts and
**    configuration headers such as yuni/platform.h in order to create a
**    customised build setup of YUNI with the otherwise unmodified source code,
**    does not constitute a derived work
**  * Building against YUNI headers which have inlined code does not constitute a
**    derived work
**  * Code which subclasses YUNI classes outside of the YUNI libraries does not
**    form a derived work
**  * Statically linking the YUNI libraries into a user application does not make
**    the user application a derived work.
**  * Using source code obsfucation on the YUNI source code when distributing it
**    is not permitted.
** As per the terms of the LGPL, a "derived work" is one for which you have to
** distribute source code for, so when the clauses above define something as not
** a derived work, it means you don't have to distribute source code for it.
** However, the original YUNI source code with all modifications must always be
** made available.
*/
#ifndef __CPP_PARSER_JSON_DFA_HXX__
# define __CPP_PARSER_JSON_DFA_HXX__

// Generated by grammar-converter


# include <yuni/yuni.h>


namespace Grammar
{
namespace Private
{
namespace JSON
{
namespace DFA
{

	enum { count = 40 };



	struct State
	{
		//! Entry symbol
		uint charset;
		//! Action
		uint target;
	};




	static const State statesForDFA0[14] = {
		{    0,    1 },
		{    1,    2 },
		{    2,    3 },
		{    3,    4 },
		{    4,    5 },
		{    5,    6 },
		{    6,    7 },
		{    7,    8 },
		{    8,   13 },
		{    9,   17 },
		{   10,   18 },
		{   11,   24 },
		{   12,   26 },
		{   13,   36 },
	};

	static const State statesForDFA1[1] = {
		{    0,    1 },
	};

	static const State statesForDFA2[1] = {
		{ (uint) -1, (uint) -1 }, // only here to not have an empty set
	};

	static const State statesForDFA3[1] = {
		{ (uint) -1, (uint) -1 }, // only here to not have an empty set
	};

	static const State statesForDFA4[1] = {
		{ (uint) -1, (uint) -1 }, // only here to not have an empty set
	};

	static const State statesForDFA5[1] = {
		{ (uint) -1, (uint) -1 }, // only here to not have an empty set
	};

	static const State statesForDFA6[1] = {
		{ (uint) -1, (uint) -1 }, // only here to not have an empty set
	};

	static const State statesForDFA7[1] = {
		{ (uint) -1, (uint) -1 }, // only here to not have an empty set
	};

	static const State statesForDFA8[1] = {
		{   14,    9 },
	};

	static const State statesForDFA9[1] = {
		{   15,   10 },
	};

	static const State statesForDFA10[1] = {
		{   16,   11 },
	};

	static const State statesForDFA11[1] = {
		{   17,   12 },
	};

	static const State statesForDFA12[1] = {
		{ (uint) -1, (uint) -1 }, // only here to not have an empty set
	};

	static const State statesForDFA13[1] = {
		{   18,   14 },
	};

	static const State statesForDFA14[1] = {
		{   15,   15 },
	};

	static const State statesForDFA15[1] = {
		{   15,   16 },
	};

	static const State statesForDFA16[1] = {
		{ (uint) -1, (uint) -1 }, // only here to not have an empty set
	};

	static const State statesForDFA17[2] = {
		{   10,   18 },
		{   11,   24 },
	};

	static const State statesForDFA18[2] = {
		{   19,   19 },
		{   20,   21 },
	};

	static const State statesForDFA19[1] = {
		{   21,   20 },
	};

	static const State statesForDFA20[2] = {
		{   20,   21 },
		{   21,   20 },
	};

	static const State statesForDFA21[2] = {
		{   21,   23 },
		{   22,   22 },
	};

	static const State statesForDFA22[1] = {
		{   21,   23 },
	};

	static const State statesForDFA23[1] = {
		{   21,   23 },
	};

	static const State statesForDFA24[3] = {
		{   19,   19 },
		{   20,   21 },
		{   21,   25 },
	};

	static const State statesForDFA25[3] = {
		{   19,   19 },
		{   20,   21 },
		{   21,   25 },
	};

	static const State statesForDFA26[3] = {
		{   12,   30 },
		{   23,   27 },
		{   24,   28 },
	};

	static const State statesForDFA27[3] = {
		{   12,   30 },
		{   23,   27 },
		{   24,   28 },
	};

	static const State statesForDFA28[2] = {
		{   18,   31 },
		{   25,   29 },
	};

	static const State statesForDFA29[3] = {
		{   12,   30 },
		{   23,   27 },
		{   24,   28 },
	};

	static const State statesForDFA30[1] = {
		{ (uint) -1, (uint) -1 }, // only here to not have an empty set
	};

	static const State statesForDFA31[1] = {
		{   26,   32 },
	};

	static const State statesForDFA32[1] = {
		{   26,   33 },
	};

	static const State statesForDFA33[1] = {
		{   26,   34 },
	};

	static const State statesForDFA34[1] = {
		{   26,   35 },
	};

	static const State statesForDFA35[3] = {
		{   12,   30 },
		{   23,   27 },
		{   24,   28 },
	};

	static const State statesForDFA36[1] = {
		{   27,   37 },
	};

	static const State statesForDFA37[1] = {
		{   18,   38 },
	};

	static const State statesForDFA38[1] = {
		{   17,   39 },
	};

	static const State statesForDFA39[1] = {
		{ (uint) -1, (uint) -1 }, // only here to not have an empty set
	};




	struct Entry
	{
		//! Total number of symbols
		const uint stateCount;
		//! List of symbols
		const State* states;
		//! Accept symbol
		const Symbols::ID acceptSymbol;
	};

	static const Entry table[count] = 
	{
		/*    0 */ {   14, statesForDFA0, (Symbols::ID)  Grammar::JSON::symUnknown /*no symbol*/ },
		/*    1 */ {    1, statesForDFA1, (Symbols::ID)    2 },
		/*    2 */ {    0, statesForDFA2, (Symbols::ID)    3 },
		/*    3 */ {    0, statesForDFA3, (Symbols::ID)    4 },
		/*    4 */ {    0, statesForDFA4, (Symbols::ID)    5 },
		/*    5 */ {    0, statesForDFA5, (Symbols::ID)    6 },
		/*    6 */ {    0, statesForDFA6, (Symbols::ID)    7 },
		/*    7 */ {    0, statesForDFA7, (Symbols::ID)    8 },
		/*    8 */ {    1, statesForDFA8, (Symbols::ID)  Grammar::JSON::symUnknown /*no symbol*/ },
		/*    9 */ {    1, statesForDFA9, (Symbols::ID)  Grammar::JSON::symUnknown /*no symbol*/ },
		/*   10 */ {    1, statesForDFA10, (Symbols::ID)  Grammar::JSON::symUnknown /*no symbol*/ },
		/*   11 */ {    1, statesForDFA11, (Symbols::ID)  Grammar::JSON::symUnknown /*no symbol*/ },
		/*   12 */ {    0, statesForDFA12, (Symbols::ID)    9 },
		/*   13 */ {    1, statesForDFA13, (Symbols::ID)  Grammar::JSON::symUnknown /*no symbol*/ },
		/*   14 */ {    1, statesForDFA14, (Symbols::ID)  Grammar::JSON::symUnknown /*no symbol*/ },
		/*   15 */ {    1, statesForDFA15, (Symbols::ID)  Grammar::JSON::symUnknown /*no symbol*/ },
		/*   16 */ {    0, statesForDFA16, (Symbols::ID)   10 },
		/*   17 */ {    2, statesForDFA17, (Symbols::ID)  Grammar::JSON::symUnknown /*no symbol*/ },
		/*   18 */ {    2, statesForDFA18, (Symbols::ID)   11 },
		/*   19 */ {    1, statesForDFA19, (Symbols::ID)  Grammar::JSON::symUnknown /*no symbol*/ },
		/*   20 */ {    2, statesForDFA20, (Symbols::ID)   11 },
		/*   21 */ {    2, statesForDFA21, (Symbols::ID)  Grammar::JSON::symUnknown /*no symbol*/ },
		/*   22 */ {    1, statesForDFA22, (Symbols::ID)  Grammar::JSON::symUnknown /*no symbol*/ },
		/*   23 */ {    1, statesForDFA23, (Symbols::ID)   11 },
		/*   24 */ {    3, statesForDFA24, (Symbols::ID)   11 },
		/*   25 */ {    3, statesForDFA25, (Symbols::ID)   11 },
		/*   26 */ {    3, statesForDFA26, (Symbols::ID)  Grammar::JSON::symUnknown /*no symbol*/ },
		/*   27 */ {    3, statesForDFA27, (Symbols::ID)  Grammar::JSON::symUnknown /*no symbol*/ },
		/*   28 */ {    2, statesForDFA28, (Symbols::ID)  Grammar::JSON::symUnknown /*no symbol*/ },
		/*   29 */ {    3, statesForDFA29, (Symbols::ID)  Grammar::JSON::symUnknown /*no symbol*/ },
		/*   30 */ {    0, statesForDFA30, (Symbols::ID)   12 },
		/*   31 */ {    1, statesForDFA31, (Symbols::ID)  Grammar::JSON::symUnknown /*no symbol*/ },
		/*   32 */ {    1, statesForDFA32, (Symbols::ID)  Grammar::JSON::symUnknown /*no symbol*/ },
		/*   33 */ {    1, statesForDFA33, (Symbols::ID)  Grammar::JSON::symUnknown /*no symbol*/ },
		/*   34 */ {    1, statesForDFA34, (Symbols::ID)  Grammar::JSON::symUnknown /*no symbol*/ },
		/*   35 */ {    3, statesForDFA35, (Symbols::ID)  Grammar::JSON::symUnknown /*no symbol*/ },
		/*   36 */ {    1, statesForDFA36, (Symbols::ID)  Grammar::JSON::symUnknown /*no symbol*/ },
		/*   37 */ {    1, statesForDFA37, (Symbols::ID)  Grammar::JSON::symUnknown /*no symbol*/ },
		/*   38 */ {    1, statesForDFA38, (Symbols::ID)  Grammar::JSON::symUnknown /*no symbol*/ },
		/*   39 */ {    0, statesForDFA39, (Symbols::ID)   13 },

	}; // table






} // namespace DFA
} // namespace JSON
} // namespace Private
} // namespace Grammar

#endif // __CPP_PARSER_JSON_DFA_HXX__
